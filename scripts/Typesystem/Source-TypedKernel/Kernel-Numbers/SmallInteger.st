'From Pharo1.4a of ''16 June 2011'' [Latest update: #14301] on 25 February 2012 at 9:37:31 pm'!Integer subclass: #SmallInteger	uses: TTyped	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Numbers'!!SmallInteger commentStamp: '<historical>' prior: 0!My instances are 31-bit numbers, stored in twos complement form. The allowable range is approximately +- 1 billion (see SmallInteger minVal, maxVal).!!SmallInteger methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/25/2012 20:31'!(?)* (Number)aNumber 	"Primitive. Multiply the receiver by the argument and answer with the	result if it is a SmallInteger. Fail if the argument or the result is not a	SmallInteger. Essential. No Lookup. See Object documentation whatIsAPrimitive."	<primitive: 9>	^ super * aNumber! !!SmallInteger methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/25/2012 20:31'!(?) + (Number)aNumber 	"Primitive. Add the receiver to the argument and answer with the result	if it is a SmallInteger. Fail if the argument or the result is not a	SmallInteger  Essential  No Lookup. See Object documentation whatIsAPrimitive."	<primitive: 1>	^ super + aNumber! !!SmallInteger methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/25/2012 20:32'!(?) - (Number)aNumber 	"Primitive. Subtract the argument from the receiver and answer with the	result if it is a SmallInteger. Fail if the argument or the result is not a	SmallInteger. Essential. No Lookup. See Object documentation	whatIsAPrimitive."	<primitive: 2>	^super - aNumber! !!SmallInteger methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/25/2012 20:32'!(?) / (Number)aNumber 	"Primitive. This primitive (for /) divides the receiver by the argument	and returns the result if the division is exact. Fail if the result is not a	whole integer. Fail if the argument is 0 or is not a SmallInteger. Optional.	No Lookup. See Object documentation whatIsAPrimitive."	<primitive: 10>	aNumber isZero ifTrue: [^(ZeroDivide dividend: self) signal].	^(aNumber isMemberOf: SmallInteger)		ifTrue: [(Fraction numerator: self denominator: aNumber) reduced]		ifFalse: [super / aNumber]! !!SmallInteger methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/25/2012 20:32'!(?) // (Number)aNumber 	"Primitive. Divide the receiver by the argument and answer with the	result. Round the result down towards negative infinity to make it a	whole integer. Fail if the argument is 0 or is not a SmallInteger.	Essential. No Lookup. See Object documentation whatIsAPrimitive. "	<primitive: 12>	^ super // aNumber 	"Do with quo: if primitive fails"! !!SmallInteger methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/25/2012 20:33'!(?) \\ (Number)aNumber 	"Primitive. Take the receiver modulo the argument. The result is the	remainder rounded towards negative infinity, of the receiver divided by	the argument Fail if the argument is 0 or is not a SmallInteger. Optional.	No Lookup. See Object documentation whatIsAPrimitive."	<primitive: 11>	^ super \\ aNumber 	"will use // to compute it if primitive fails"! !!SmallInteger methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/25/2012 20:34'!(Integer) gcd: (Integer)anInteger 	"See SmallInteger (Integer) | gcd:"	| (Integer)n (Integer)m |	n := self.	m := anInteger.	[n = 0]		whileFalse: 			[n := (<Integer>m \\ (m := n))].	^ m abs! !!SmallInteger methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/25/2012 20:35'!(Integer) quo: (Number)aNumber	"Primitive. Divide the receiver by the argument and answer with the 	result. Round the result down towards zero to make it a whole integer. 	Fail if the argument is 0 or is not a SmallInteger. Optional. See Object 	documentation whatIsAPrimitive."	<primitive: 13>	aNumber = 0 ifTrue: [^ (ZeroDivide dividend: self) signal].	(aNumber isMemberOf: SmallInteger)		ifFalse: [^ super quo: aNumber].	(aNumber = -1 and: [self = self class minVal])		ifTrue: ["result is aLargeInteger" ^ self negated].	^self primitiveFailed! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'EstebanAllende 2/25/2012 20:36'!(Integer) bitAnd: (Integer)arg 	"Primitive. Answer an Integer whose bits are the logical OR of the	receiver's bits and those of the argument, arg.	Numbers are interpreted as having 2's-complement representation.	Essential.  See Object documentation whatIsAPrimitive."	<primitive: 14>	self >= 0 ifTrue: [^ arg bitAnd: self].	^ (self bitInvert bitOr: arg bitInvert) bitInvert.! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'EstebanAllende 2/25/2012 20:36'!(Integer) bitOr: (Integer)arg 	"Primitive. Answer an Integer whose bits are the logical OR of the	receiver's bits and those of the argument, arg.	Numbers are interpreted as having 2's-complement representation.	Essential.  See Object documentation whatIsAPrimitive."	<primitive: 15>	self >= 0 ifTrue: [^ arg bitOr: self].	^ arg < 0		ifTrue: [(self bitInvert bitAnd: arg bitInvert) bitInvert]		ifFalse: [(self bitInvert bitClear: arg) bitInvert]! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'EstebanAllende 2/25/2012 20:36'!(Integer) bitShift: (Integer)arg 	"Primitive. Answer an Integer whose value is the receiver's value shifted	left by the number of bits indicated by the argument. Negative arguments	shift right. The receiver is interpreted as having 2's-complement representation.	Essential.  See Object documentation whatIsAPrimitive."	<primitive: 17>	self >= 0 ifTrue: [^ super bitShift: arg].	^ arg >= 0		ifTrue: [(self negated bitShift: arg) negated]		ifFalse: [(self bitInvert bitShift: arg) bitInvert].! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'EstebanAllende 2/25/2012 20:37'!(Integer) bitStringLength      "Always use as many bits as the native format to represent a SmallInteger"      ^self class maxVal highBit + 1! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'EstebanAllende 2/25/2012 20:37'!(Integer) bitXor: (Integer)arg 	"Primitive. Answer an Integer whose bits are the logical XOR of the	receiver's bits and those of the argument, arg.	Numbers are interpreted as having 2's-complement representation.	Essential.  See Object documentation whatIsAPrimitive."	<primitive: 16>	self >= 0 ifTrue: [^ arg bitXor: self].	^ arg < 0		ifTrue: [self bitInvert bitXor: arg bitInvert]		ifFalse: [(self bitInvert bitXor: arg) bitInvert].! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'EstebanAllende 2/25/2012 20:37'!(Integer) hashMultiply	| (Integer)low |	low := self bitAnd: 16383.	^(16r260D * low + ((16r260D * (self bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384))			bitAnd: 16r0FFFFFFF! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'EstebanAllende 2/25/2012 20:37'!(Integer) highBit	"Answer the index of the high order bit of the receiver, or zero if the  	receiver is zero. Raise an error if the receiver is negative, since  	negative integers are defined to have an infinite number of leading 1's 	in 2's-complement arithmetic. Use >>highBitOfMagnitude if you want to 	get the highest bit of the magnitude."	self < 0 ifTrue: [^ self error: 'highBit is not defined for negative integers'].	^ self highBitOfPositiveReceiver! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'EstebanAllende 2/25/2012 20:38'!(Integer) highBitOfMagnitude	"Answer the index of the high order bit of the receiver, or zero if the  	receiver is zero. This method is used for negative SmallIntegers as well,  	since Pharo's LargeIntegers are sign/magnitude."		self < 0 ifTrue: [		"Beware: do not use highBitOfPositiveReceiver		because self negated is not necessarily a SmallInteger		(see SmallInteger minVal)"		^self negated highBitOfMagnitude].		"Implementation note: this method could be as well inlined here."	^self highBitOfPositiveReceiver! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'EstebanAllende 2/25/2012 20:38'!(Integer) lowBit	" Answer the index of the low order one bit.		2r00101000 lowBit       (Answers: 4)		2r-00101000 lowBit      (Answers: 4)	  First we skip bits in groups of 8, then do a lookup in a table.	  While not optimal, this is a good tradeoff; long	  integer #lowBit always invokes us with bytes."	| (Integer)n (Integer)result (Integer)lastByte |	n := self.	n = 0 ifTrue: [ ^ 0 ].	result := 0.	[(lastByte := n bitAnd: 16rFF) = 0]		whileTrue: [			result := result + 8.			n := n bitShift: -8 ].	"The low bits table can be obtained with:	((1 to: 8) inject: #[1] into: [:lowBits :rank | (lowBits copy at: 1 put: lowBits first + 1; yourself) , lowBits]) allButFirst."	^result + ( #[1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 8 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1] at: lastByte)! !!SmallInteger methodsFor: 'comparing' stamp: 'EstebanAllende 2/25/2012 20:39'!(Boolean) < (Magnitude)aNumber 	"Primitive. Compare the receiver with the argument and answer with	true if the receiver is less than the argument. Otherwise answer false.	Fail if the argument is not a SmallInteger. Essential. No Lookup. See	Object documentation whatIsAPrimitive."	<primitive: 3>	^super < aNumber! !!SmallInteger methodsFor: 'comparing' stamp: 'EstebanAllende 2/25/2012 20:39'!(Boolean) <= (Magnitude)aNumber 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is less than or equal to the argument. Otherwise answer	false. Fail if the argument is not a SmallInteger. Optional. No Lookup.	See Object documentation whatIsAPrimitive. "	<primitive: 5>	^super <= aNumber! !!SmallInteger methodsFor: 'comparing' stamp: 'EstebanAllende 2/25/2012 20:39'!(Boolean) = (Object)aNumber 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is equal to the argument. Otherwise answer false. Fail if the	argument is not a SmallInteger. Essential. No Lookup. See Object	documentation whatIsAPrimitive. "	<primitive: 7>	^super = aNumber! !!SmallInteger methodsFor: 'comparing' stamp: 'EstebanAllende 2/25/2012 20:39'!(Boolean) > (Magnitude)aNumber 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is greater than the argument. Otherwise answer false. Fail if	the argument is not a SmallInteger. Essential. No Lookup. See Object	documentation whatIsAPrimitive."	<primitive: 4>	^super > aNumber! !!SmallInteger methodsFor: 'comparing' stamp: 'EstebanAllende 2/25/2012 20:40'!(Boolean) >= (Magnitude)aNumber 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is greater than or equal to the argument. Otherwise answer	false. Fail if the argument is not a SmallInteger. Optional. No Lookup.	See Object documentation whatIsAPrimitive."	<primitive: 6>	^super >= aNumber! !!SmallInteger methodsFor: 'comparing' stamp: 'EstebanAllende 2/25/2012 20:40'!(Integer) hash	^self! !!SmallInteger methodsFor: 'comparing' stamp: 'EstebanAllende 2/25/2012 20:46'!(SmallInteger) identityHash	^(<SmallInteger>self hashMultiply)! !!SmallInteger methodsFor: 'comparing' stamp: 'EstebanAllende 2/25/2012 20:46'!(Boolean) ~= (Object)aNumber 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is not equal to the argument. Otherwise answer false. Fail if	the argument is not a SmallInteger. Essential. No Lookup. See Object	documentation whatIsAPrimitive."	<primitive: 8>	^super ~= aNumber! !!SmallInteger methodsFor: 'converting' stamp: 'EstebanAllende 2/25/2012 20:54'!(SmallInteger) as31BitSmallInt	"Polymorphic with LargePositiveInteger (see comment there).	 Return self since all SmallIntegers are 31 bits"	^ self! !!SmallInteger methodsFor: 'converting' stamp: 'EstebanAllende 2/25/2012 20:55'!(Float)asFloat	"Primitive. Answer a Float that represents the value of the receiver.	Essential. See Object documentation whatIsAPrimitive."	<primitive: 40>	self primitiveFailed.	^nil! !!SmallInteger methodsFor: 'copying' stamp: 'EstebanAllende 2/25/2012 20:55'!(Self) deepCopy! !!SmallInteger methodsFor: 'copying' stamp: 'EstebanAllende 2/25/2012 20:55'!(Self) shallowCopy! !!SmallInteger methodsFor: 'copying' stamp: 'EstebanAllende 2/25/2012 20:56'!(Self) veryDeepCopyWith: (DeepCopier)deepCopier	"Return self.  I can't be copied.  Do not record me."! !!SmallInteger methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/25/2012 20:56'!(Number) sqrt	self negative ifTrue: [		^ DomainError signal: 'sqrt undefined for number less than zero.' ].	^super sqrt! !!SmallInteger methodsFor: 'memory' stamp: 'EstebanAllende 2/25/2012 20:57'!(Integer) sizeInMemory    "SmallInteger occupy 0 bytes since the only space occupied by a SmallInteger is the space of the slot containing it.  There is no SmallInteger object beyond the slot. From another POV, it could be 4, the size of the slot. But we don't count the size of the slots, they are already counted in the containing object, that's why it should answer 0."   ^0.! !!SmallInteger methodsFor: 'pointers' stamp: 'EstebanAllende 2/25/2012 20:57'!(Boolean) pointsTo: (ProtoObject)anObject	"Answers true if I hold a reference to anObject, or false otherwise. But since SmallIntegers do not have pointers, it always answers false"	^false! !!SmallInteger methodsFor: 'printing' stamp: 'EstebanAllende 2/25/2012 20:58'!(Integer)decimalDigitLength	"Answer the number of digits printed out in base 10.	Note that this only works for positive SmallIntegers."		^ self < 10000		ifTrue: [self < 100				ifTrue: [self < 10						ifTrue: [1]						ifFalse: [2]]				ifFalse: [self < 1000						ifTrue: [3]						ifFalse: [4]]]		ifFalse: [self < 1000000				ifTrue: [self < 100000						ifTrue: [5]						ifFalse: [6]]				ifFalse: [self < 100000000						ifTrue: [self < 10000000								ifTrue: [7]								ifFalse: [8]]						ifFalse: [self < 1000000000								ifTrue: [9]								ifFalse: [10]]]]! !!SmallInteger methodsFor: 'printing' stamp: 'EstebanAllende 2/25/2012 20:58'!(LargePositiveInteger) destinationBuffer: (Integer)digitLength  ^ LargePositiveInteger new: digitLength.! !!SmallInteger methodsFor: 'printing' stamp: 'EstebanAllende 2/25/2012 20:59'!(Integer) numberOfDigitsInBase: (Integer)b 	"Return how many digits are necessary to print this number in base b.	Mostly same as super but an optimized version for base 10 case"		b = 10 ifFalse: [^super numberOfDigitsInBase: b].	self < 0 ifTrue: [^self negated numberOfDigitsInBase: b].	^self decimalDigitLength! !!SmallInteger methodsFor: 'printing' stamp: 'EstebanAllende 2/25/2012 20:59'!(Self) printOn: (Stream)stream base: (Integer)base 	"Append a representation of this number in base b on aStream."	self printOn: stream base: base length: 0 padded: false! !!SmallInteger methodsFor: 'printing' stamp: 'EstebanAllende 2/25/2012 21:03'!(Self) printOn: (Stream)stream base: (Integer)base length: (Integer)minimumLength padded: (Boolean)padWithZeroes	| (Integer)n (Integer)numberOfDigits (Integer)totalLength (Integer)divisor |	self < 0		ifTrue: [			n := self negated.			totalLength := 1 ]		ifFalse: [			n := self.			totalLength := 0 ].	numberOfDigits := n numberOfDigitsInBase: base.	totalLength := totalLength + numberOfDigits.	padWithZeroes ifFalse: [		[ totalLength < minimumLength ] whileTrue: [			(<WriteStream>stream) space.			totalLength := totalLength + 1 ] ].	n = self ifFalse: [ stream nextPut: $- ].	padWithZeroes ifTrue: [		[ totalLength < minimumLength ] whileTrue: [			stream nextPut: $0.			totalLength := totalLength + 1 ] ].	divisor := (<Integer>base raisedToInteger: numberOfDigits - 1).	[ divisor > 0 ] whileTrue: [		| digit |		digit := n // divisor.		stream nextPut: ('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' at: digit + 1).		n := n - (digit * divisor).		divisor := divisor // base ]! !!SmallInteger methodsFor: 'printing' stamp: 'EstebanAllende 2/25/2012 21:04'!(Self) printOn: (Stream)aStream base: (Integer)b nDigits: (Integer)n 	"Append a representation of this number in base b on aStream using nDigits.	self must be positive."	self printOn: aStream base: b length: n padded: true! !!SmallInteger methodsFor: 'printing' stamp: 'EstebanAllende 2/25/2012 21:05'!(String) printString	"Highly optimized version for base 10	and that we know it is a SmallInteger."		| (Integer)integer (Integer)next (String)result (Integer)len |	self = 0 ifTrue: [^'0'].	self < 0 ifTrue: [^'-', self negated printString].	len := self decimalDigitLength.	result := String new: len.	integer := self.	len to: 1 by: -1 do: [:(Integer)i |		next := integer // 10.		result byteAt: i put: 48 + (integer - (next * 10)).		integer := next].	^result! !!SmallInteger methodsFor: 'printing' stamp: 'EstebanAllende 2/25/2012 21:06'!(String) printStringBase: (Integer)b 	"Return a String representation of this number in base b.	For SmallIntegers, it is more efficient to print directly in a String,	rather than using a Stream like super."	self < 0		ifTrue: [^ '-'				, (self negated printStringBase: b)].	self < b		ifTrue: [^ String				with: (Character digitValue: self)].	^ self printStringBase: b nDigits: (self numberOfDigitsInBase: b)! !!SmallInteger methodsFor: 'printing' stamp: 'EstebanAllende 2/25/2012 21:08'!(String) printStringBase: (Integer)b nDigits: (Integer)n	"Return a string representation of this number in base b with n digits (left padded with 0).	Should be invoked with: 0 <= self < (b raisedToInteger: n)."		| (Integer)integer (Integer)next (String)result |	result := String new: n.	integer := self.	n to: 1 by: -1 do: [:(Integer)i |		next := integer // b.		result byteAt: i put: (Character digitValue: (integer - (next * b))).		integer := next].	^result! !!SmallInteger methodsFor: 'printing' stamp: 'EstebanAllende 2/25/2012 21:09'!(String) threeDigitName	| (Array)units (String)answer |	self = 0 ifTrue: [^''].	units := #('one' 'two' 'three' 'four' 'five' 'six' 'seven' 'eight' 'nine' 'ten' 		'eleven' 'twelve' 'thirteen' 'fourteen' 'fifteen' 'sixteen' 'seventeen' 		'eighteen' 'nineteen').	self > 99 ifTrue: [		answer := (units at: self // 100),' hundred'.		(self \\ 100) = 0 ifFalse: [			answer := answer,' ',(self \\ 100) threeDigitName		].		^answer	].	self < 20 ifTrue: [		^units at: self	].	answer := #('twenty' 'thirty' 'forty' 'fifty' 'sixty' 'seventy' 'eighty' 'ninety')			at: self // 10 - 1.	(self \\ 10) = 0 ifFalse: [		answer := answer,'-',(units at: self \\ 10)	].	^answer! !!SmallInteger methodsFor: 'system primitives' stamp: 'EstebanAllende 2/25/2012 21:10'!(SmallInteger) basicIdentityHash	^self! !!SmallInteger methodsFor: 'system primitives' stamp: 'EstebanAllende 2/25/2012 21:13'!(SmallInteger) digitAt: (Integer)n 	"Answer the value of an indexable field in the receiver.  LargePositiveInteger uses bytes of base two number, and each is a 'digit' base 256.  Fail if the argument (the index) is not an Integer or is out of bounds."	n>4 ifTrue: [^ 0].	self < 0		ifTrue: 			[self = SmallInteger minVal ifTrue:				["Can't negate minVal -- treat specially"				^(<SmallInteger>#(0 0 0 64) at: n)].			^ (<SmallInteger>((0-self) bitShift: (1-n)*8) bitAnd: 16rFF)]		ifFalse: [^(<SmallInteger>(self bitShift: (1-n)*8) bitAnd: 16rFF)]! !!SmallInteger methodsFor: 'system primitives' stamp: 'EstebanAllende 2/25/2012 21:16'!(Integer) digitAt: (Integer)n put: (Integer)value 	"Fails. The digits of a small integer can not be modified."	self error: 'You can''t store in a SmallInteger'! !!SmallInteger methodsFor: 'system primitives' stamp: 'EstebanAllende 2/25/2012 21:17'!(Integer) digitLength	"Answer the number of indexable fields in the receiver. This value is the 	same as the largest legal subscript. Included so that a SmallInteger can 	behave like a LargePositiveInteger or LargeNegativeInteger."	(self < 16r100 and: [self > -16r100]) ifTrue: [^ 1].	(self < 16r10000 and: [self > -16r10000]) ifTrue: [^ 2].	(self < 16r1000000 and: [self > -16r1000000]) ifTrue: [^ 3].	^ 4! !!SmallInteger methodsFor: 'system primitives' stamp: 'EstebanAllende 2/25/2012 21:17'!(?) instVarAt: (Integer)i 	"Small integer has to be specially handled."	i = 1 ifTrue: [^self].	self error: 'argument too big for small integer instVarAt:'! !!SmallInteger methodsFor: 'system primitives' stamp: 'EstebanAllende 2/25/2012 21:18'!(Self) nextInstance	"SmallIntegers can't be enumerated this way.  There are a finite number of them from from (SmallInteger minVal) to (SmallInteger maxVal), but you'll have to enumerate them yourself with:	(SmallInteger minVal) to: (SmallInteger maxVal) do: [:integer | <your code here>].	"	^self shouldNotImplement ! !!SmallInteger methodsFor: 'system primitives' stamp: 'EstebanAllende 2/25/2012 21:18'!(Object) nextObject	"SmallIntegers are immediate objects, and, as such, do not have successors in object memory."	^self shouldNotImplement ! !!SmallInteger methodsFor: 'testing' stamp: 'EstebanAllende 2/25/2012 21:19'!(Boolean) even	^(self bitAnd: 1) = 0! !!SmallInteger methodsFor: 'testing' stamp: 'EstebanAllende 2/25/2012 21:19'!(Boolean) isLarge	^false! !!SmallInteger methodsFor: 'testing' stamp: 'EstebanAllende 2/25/2012 21:20'!(Boolean) odd	^(self bitAnd: 1) = 1! !!SmallInteger methodsFor: 'private' stamp: 'EstebanAllende 2/25/2012 21:23'!(Integer)fromString: (String)str radix: (Integer)radix	| (Integer)maxdigit (Character)c (Integer)val |	maxdigit := 		radix + (radix > 10					ifTrue: [55 - 1]					ifFalse: [48 - 1]).	val := 0.	1 to: str size do: 		[:(Integer)i | 		c := str at: i.		(c < 48 ifFalse: [c > maxdigit])			ifTrue: [^nil].		val := val * radix + (c <= 57							ifTrue: [c - 48]							ifFalse: 								[c < 65 ifTrue: [^nil].								c - 55])].	^val! !!SmallInteger methodsFor: 'private' stamp: 'EstebanAllende 2/25/2012 21:27'!(Integer)highBitOfPositiveReceiver	| (Integer)shifted (Integer)bitNo |	"Answer the index of the high order bit of the receiver, or zero if the 	receiver is zero. Receiver has to be positive!!"	shifted := self.	bitNo := 0.	[shifted < 65536]		whileFalse: 			[shifted := shifted bitShift: -16.			bitNo := bitNo + 16].	shifted < 256		ifFalse: 			[shifted := shifted bitShift: -8.			bitNo := bitNo + 8].			"The high bits table can be obtained with:	(1 to: 8) inject: #[0] into: [:highBits :rank | highBits , (highBits collect: [:e | rank])]."	^bitNo + ( #[0 1 2 2 3 3 3 3 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8] at: shifted + 1)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmallInteger class	uses: TTyped classTrait	instanceVariableNames: ''!!SmallInteger class methodsFor: 'constants'!maxVal	"Answer the maximum value for a SmallInteger."	^ 16r3FFFFFFF! !!SmallInteger class methodsFor: 'constants'!minVal	"Answer the minimum value for a SmallInteger."	^ -16r40000000! !!SmallInteger class methodsFor: 'documentation'!guideToDivision	"Handy guide to the kinds of Integer division: 	/  exact division, returns a fraction if result is not a whole integer. 	//  returns an Integer, rounded towards negative infinity. 	\\ is modulo rounded towards negative infinity. 	quo:  truncated division, rounded towards zero."! !!SmallInteger class methodsFor: 'instance creation' stamp: 'tk 4/20/1999 14:17'!basicNew	self error: 'SmallIntegers can only be created by performing arithmetic'! !!SmallInteger class methodsFor: 'instance creation' stamp: 'tk 4/20/1999 14:18'!new	self basicNew	"generates an error"! !!SmallInteger class methodsFor: 'plugin generation' stamp: 'acg 9/20/1999 11:20'!ccgCanConvertFrom: anObject	^anObject class == self! !